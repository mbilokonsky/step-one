const createGrid = require("../src/grid");
const grid_utils = require("../src/grid_utils");

describe("grid_utils", () => {
  describe(".lookup_index_for_point", () => {
    it("correctly handles 1-dimensional grids", () => {
      const dimensions = [2];
      const subject = grid_utils.lookup_index_for_point.bind(null, dimensions);
      expect(subject([0])).toEqual(0);
      expect(subject([1])).toEqual(1);
    });

    it("correctly handles a 2-dimensional grid", () => {
      const dimensions = [2, 3];
      const subject = grid_utils.lookup_index_for_point.bind(null, dimensions);
      expect(subject([0, 0])).toEqual(0);
      expect(subject([1, 0])).toEqual(1);
      expect(subject([0, 1])).toEqual(2);
      expect(subject([1, 1])).toEqual(3);
      expect(subject([0, 2])).toEqual(4);
      expect(subject([1, 2])).toEqual(5);
    });

    it("correctly handles a 3-dimensional grid", () => {
      const dimensions = [3, 3, 2];
      const subject = grid_utils.lookup_index_for_point.bind(null, dimensions);

      const point1 = [0, 0, 0];
      const index1 = 0;

      const point2 = [1, 1, 1];
      const index2 = 13;

      const point3 = [0, 2, 1];
      const index3 = 15;

      expect(subject(point1)).toEqual(index1);
      expect(subject(point2)).toEqual(index2);
      expect(subject(point3)).toEqual(index3);
    });
  });

  describe(".get_coordinates_for_index", () => {
    it("correctly gets 1-dimensional coordinates", () => {
      const dimensions = [2];
      const subject = grid_utils.get_coordinates_for_index.bind(
        null,
        dimensions
      );
      expect(subject(0)).toEqual([0]);
      expect(subject(1)).toEqual([1]);
    });

    it("correctly gets 2-dimensional coordinates", () => {
      const dimensions = [2, 3];
      const subject = grid_utils.get_coordinates_for_index.bind(
        null,
        dimensions
      );

      expect(subject(0)).toEqual([0, 0]);
      expect(subject(1)).toEqual([1, 0]);
      expect(subject(2)).toEqual([0, 1]);
      expect(subject(3)).toEqual([1, 1]);
      expect(subject(4)).toEqual([0, 2]);
      expect(subject(5)).toEqual([1, 2]);
    });

    it("correctly gets 3-dimensional coordinates", () => {
      const dimensions = [3, 3, 2];
      const subject = grid_utils.get_coordinates_for_index.bind(
        null,
        dimensions
      );

      expect(subject(0)).toEqual([0, 0, 0]);
      expect(subject(2)).toEqual([2, 0, 0]);
      expect(subject(3)).toEqual([0, 1, 0]);
      expect(subject(15)).toEqual([0, 2, 1]);
    });
  });

  describe(".get_array_size", () => {
    it("handles 1D arrays", () => {
      expect(grid_utils.get_array_size([3])).toBe(3);
    });

    it("handles 2D arrays", () => {
      expect(grid_utils.get_array_size([3, 3])).toBe(9);
    });

    it("handles 3D arrays", () => {
      expect(grid_utils.get_array_size([3, 3, 3])).toBe(27);
    });
  });

  describe(".clone", () => {
    it("returns a new array with the same dimensions and values as the old one", () => {
      const grid = createGrid([30, 30]);
      grid[10] = 30;
      const clone = grid_utils.clone(grid);
      grid[10] = 40;

      expect(clone.length).toBe(grid.length);
      expect(grid[10]).toBe(40);
      expect(clone[10]).toBe(30);
    });
  });

  describe(".apply_rule", () => {
    it("returns a delta where cells represent state transitions.", () => {});
  });

  describe(".apply_delta", () => {
    it("returns a new grid generated by flipping every cell in the delta.", () => {
      const grid = createGrid([30, 30]);
      expect(grid[11].value).toBe(false);
      grid[11].value = true;
      expect(grid[10].value).toBe(false);
      expect(grid[11].value).toBe(true);

      const delta = createGrid([30, 30]);
      delta[10].value = true;
      delta[11].value = true;

      const new_grid = grid_utils.apply_delta(grid, delta);
      expect(new_grid[10].value).toBe(true);
      expect(new_grid[11].value).toBe(false);
    });
  });

  describe(".find_neighbors", () => {
    it("works in 1D", () => {
      const grid = createGrid([10]);
      const neighbors_within_1 = grid_utils.find_neighbors(grid, [3], 1);
      const neighbors_within_2 = grid_utils.find_neighbors(grid, [3], 2);

      expect(JSON.stringify(neighbors_within_1)).toEqual(
        JSON.stringify([[2], [4]])
      );
      expect(JSON.stringify(neighbors_within_2)).toEqual(
        JSON.stringify([[1], [2], [4], [5]])
      );
    });

    it("works in 2D", () => {
      const dimensions = [10, 10];
      const grid = createGrid(dimensions);
      const neighbors_within_1 = grid_utils.find_neighbors(grid, [3, 3], 1);
      const neighbors_within_2 = grid_utils.find_neighbors(grid, [3, 3], 2);

      expect(neighbors_within_1).toMatchInlineSnapshot(`
Array [
  Array [
    2,
    2,
  ],
  Array [
    3,
    2,
  ],
  Array [
    4,
    2,
  ],
  Array [
    2,
    3,
  ],
  Array [
    4,
    3,
  ],
  Array [
    2,
    4,
  ],
  Array [
    3,
    4,
  ],
  Array [
    4,
    4,
  ],
]
`);
      expect(neighbors_within_2).toMatchInlineSnapshot(`
Array [
  Array [
    1,
    1,
  ],
  Array [
    2,
    1,
  ],
  Array [
    3,
    1,
  ],
  Array [
    4,
    1,
  ],
  Array [
    5,
    1,
  ],
  Array [
    1,
    2,
  ],
  Array [
    2,
    2,
  ],
  Array [
    3,
    2,
  ],
  Array [
    4,
    2,
  ],
  Array [
    5,
    2,
  ],
  Array [
    1,
    3,
  ],
  Array [
    2,
    3,
  ],
  Array [
    4,
    3,
  ],
  Array [
    5,
    3,
  ],
  Array [
    1,
    4,
  ],
  Array [
    2,
    4,
  ],
  Array [
    3,
    4,
  ],
  Array [
    4,
    4,
  ],
  Array [
    5,
    4,
  ],
  Array [
    1,
    5,
  ],
  Array [
    2,
    5,
  ],
  Array [
    3,
    5,
  ],
  Array [
    4,
    5,
  ],
  Array [
    5,
    5,
  ],
]
`);
    });
  });
});
