const createGrid = require("../src/grid");
const grid_utils = require("../src/grid_utils");

describe("grid_utils", () => {
  describe(".lookup_index_for_point", () => {
    it("correctly handles 1-dimensional grids", () => {
      const dimensions = [2];
      const subject = grid_utils.lookup_index_for_point.bind(null, dimensions);
      expect(subject([0])).toEqual(0);
      expect(subject([1])).toEqual(1);
    });

    it("correctly handles a 2-dimensional grid", () => {
      const dimensions = [2, 3];
      const subject = grid_utils.lookup_index_for_point.bind(null, dimensions);
      expect(subject([0, 0])).toEqual(0);
      expect(subject([1, 0])).toEqual(1);
      expect(subject([0, 1])).toEqual(2);
      expect(subject([1, 1])).toEqual(3);
      expect(subject([0, 2])).toEqual(4);
      expect(subject([1, 2])).toEqual(5);
    });

    it("correctly handles a 3-dimensional grid", () => {
      const dimensions = [3, 3, 2];
      const subject = grid_utils.lookup_index_for_point.bind(null, dimensions);

      const point1 = [0, 0, 0];
      const index1 = 0;

      const point2 = [1, 1, 1];
      const index2 = 13;

      const point3 = [0, 2, 1];
      const index3 = 15;

      expect(subject(point1)).toEqual(index1);
      expect(subject(point2)).toEqual(index2);
      expect(subject(point3)).toEqual(index3);
    });
  });

  describe(".get_coordinates_for_index", () => {
    it("correctly gets 1-dimensional coordinates", () => {
      const dimensions = [2];
      const subject = grid_utils.get_coordinates_for_index.bind(
        null,
        dimensions
      );
      expect(subject(0)).toEqual([0]);
      expect(subject(1)).toEqual([1]);
    });

    it("correctly gets 2-dimensional coordinates", () => {
      const dimensions = [2, 3];
      const subject = grid_utils.get_coordinates_for_index.bind(
        null,
        dimensions
      );

      expect(subject(0)).toEqual([0, 0]);
      expect(subject(1)).toEqual([1, 0]);
      expect(subject(2)).toEqual([0, 1]);
      expect(subject(3)).toEqual([1, 1]);
      expect(subject(4)).toEqual([0, 2]);
      expect(subject(5)).toEqual([1, 2]);
    });

    it("correctly gets 3-dimensional coordinates", () => {
      const dimensions = [3, 3, 2];
      const subject = grid_utils.get_coordinates_for_index.bind(
        null,
        dimensions
      );

      expect(subject(0)).toEqual([0, 0, 0]);
      expect(subject(2)).toEqual([2, 0, 0]);
      expect(subject(3)).toEqual([0, 1, 0]);
      expect(subject(15)).toEqual([0, 2, 1]);
    });
  });

  describe(".get_array_size", () => {
    it("handles 1D arrays", () => {
      expect(grid_utils.get_array_size([3])).toBe(3);
    });

    it("handles 2D arrays", () => {
      expect(grid_utils.get_array_size([3, 3])).toBe(9);
    });

    it("handles 3D arrays", () => {
      expect(grid_utils.get_array_size([3, 3, 3])).toBe(27);
    });
  });

  describe(".clone", () => {
    it("returns a new array with the same dimensions and values as the old one", () => {
      const grid = createGrid([30, 30]);
      grid[10] = 30;
      const clone = grid_utils.clone(grid);
      grid[10] = 40;

      expect(clone.length).toBe(grid.length);
      expect(grid[10]).toBe(40);
      expect(clone[10]).toBe(30);
    });
  });

  describe(".apply_rule", () => {
    it("returns a delta where cells represent state transitions.", () => {});
  });

  describe(".apply_delta", () => {
    it("returns a new grid generated by flipping every cell in the delta.", () => {
      const grid = createGrid([30, 30]);
      expect(grid[11].value).toBe(false);
      grid[11].value = true;
      expect(grid[10].value).toBe(false);
      expect(grid[11].value).toBe(true);

      const delta = createGrid([30, 30]);
      delta[10].value = true;
      delta[11].value = true;

      const new_grid = grid_utils.apply_delta(grid, delta);
      expect(new_grid[10].value).toBe(true);
      expect(new_grid[11].value).toBe(false);
    });
  });

  describe(".find_neighbors", () => {
    const { moore, von_neumann } = require("../src/neighbors");

    describe("MOORE", () => {
      const compute_moore_size = (dimensions, radius) => {
        const per_side = 2 * radius + 1;
        const power = dimensions.length;
        const total_neighborhood_size = Math.pow(per_side, power);
        return total_neighborhood_size - 1; // remove self
      };

      it("is the default if no neighborhood type is provided", () => {
        const specify_moore = grid_utils.find_neighbors([3, 3], 1, moore);
        const no_specify = grid_utils.find_neighbors([3, 3], 1);

        expect(specify_moore).toEqual(no_specify);
      });

      it("works in 1D", () => {
        const neighbors_within_1 = grid_utils.find_neighbors([3], 1);
        const neighbors_within_2 = grid_utils.find_neighbors([3], 2);

        expect(neighbors_within_1).toMatchInlineSnapshot(`
Array [
  Array [
    2,
  ],
  Array [
    4,
  ],
]
`);
        expect(neighbors_within_2).toMatchInlineSnapshot(`
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
  Array [
    4,
  ],
  Array [
    5,
  ],
]
`);
      });

      it("works in 2D", () => {
        const dimensions = [10, 10];
        const neighbors_within_1 = grid_utils.find_neighbors([3, 3], 1);
        const expected_1 = compute_moore_size(dimensions, 1);
        const neighbors_within_2 = grid_utils.find_neighbors([3, 3], 2);
        const expected_2 = compute_moore_size(dimensions, 2);
        const neighbors_within_3 = grid_utils.find_neighbors([3, 3], 3);
        const expected_3 = compute_moore_size(dimensions, 3);

        expect(neighbors_within_1.length).toBe(expected_1);
        expect(neighbors_within_2.length).toBe(expected_2);
        expect(neighbors_within_3.length).toBe(expected_3);
      });

      it("works in 3D", () => {
        const dimensions = [10, 10, 10];

        const neighbors_within_1 = grid_utils.find_neighbors([3, 3, 3], 1);
        const expected_1 = compute_moore_size(dimensions, 1);
        const neighbors_within_2 = grid_utils.find_neighbors([3, 3, 3], 2);
        const expected_2 = compute_moore_size(dimensions, 2);
        const neighbors_within_3 = grid_utils.find_neighbors([3, 3, 3], 3);
        const expected_3 = compute_moore_size(dimensions, 3);

        expect(neighbors_within_1.length).toBe(expected_1);
        expect(neighbors_within_2.length).toBe(expected_2);
        expect(neighbors_within_3.length).toBe(expected_3);
      });
    });

    describe("VON_NEUMANN", () => {
      it("works in 1D - same output as Moore", () => {
        const neighbors_within_1 = grid_utils.find_neighbors(
          [3],
          1,
          von_neumann
        );
        const neighbors_within_2 = grid_utils.find_neighbors(
          [3],
          2,
          von_neumann
        );

        expect(neighbors_within_1).toMatchInlineSnapshot(`
Array [
  Array [
    2,
  ],
  Array [
    4,
  ],
]
`);
        expect(neighbors_within_2).toMatchInlineSnapshot(`
Array [
  Array [
    1,
  ],
  Array [
    2,
  ],
  Array [
    4,
  ],
  Array [
    5,
  ],
]
`);
      });

      it("works in 2D", () => {
        const neighbors_within_1 = grid_utils.find_neighbors(
          [3, 3],
          1,
          von_neumann
        );
        const neighbors_within_2 = grid_utils.find_neighbors(
          [3, 3],
          2,
          von_neumann
        );
        const neighbors_within_3 = grid_utils.find_neighbors(
          [3, 3],
          3,
          von_neumann
        );

        expect(neighbors_within_1.length).toBe(4);
        expect(neighbors_within_2.length).toBe(12);
        expect(neighbors_within_3.length).toBe(24);
      });

      const delannoy = require("delannoy");
      it("works in 3D", () => {
        const dimensions = [10, 10, 10];
        const neighbors_within_1 = grid_utils.find_neighbors(
          [3, 3, 3],
          1,
          von_neumann
        );
        const expected_size_1 = delannoy(dimensions.length, 1) - 1;
        const neighbors_within_2 = grid_utils.find_neighbors(
          [3, 3, 3],
          2,
          von_neumann
        );
        const expected_size_2 = delannoy(dimensions.length, 2) - 1;
        const neighbors_within_3 = grid_utils.find_neighbors(
          [3, 3, 3],
          3,
          von_neumann
        );
        const expected_size_3 = delannoy(dimensions.length, 3) - 1;

        expect(neighbors_within_1.length).toBe(expected_size_1);
        expect(neighbors_within_2.length).toBe(expected_size_2);
        expect(neighbors_within_3.length).toBe(expected_size_3);
      });
    });
  });
});
